diff --git a/criu/files.c b/criu/files.c
index 0f88912a..5c59fe01 100644
--- a/criu/files.c
+++ b/criu/files.c
@@ -461,6 +461,18 @@ static int dump_chrdev(struct fd_parms *p, int lfd, FdinfoEntry *e)
 		ops = get_misc_dev_ops(minor(p->stat.st_rdev));
 		if (ops)
 			break;
+    case 195:
+        if (minor(p->stat.st_rdev) == 255) {
+            pr_debug("found nvidia device. skipping it...\n");
+            e->type = FD_TYPES__NVIDIA;
+            return 0;
+        }
+    case 235:
+        if (minor(p->stat.st_rdev) == 0) {
+            pr_debug("found nvidia device. skipping it...\n");
+            e->type = FD_TYPES__NVIDIA;
+            return 0;
+        }
 		/* fallthrough */
 	default: {
 		char more[32];
@@ -536,6 +548,11 @@ static int dump_one_file(struct pid *pid, int fd, int lfd, struct fd_opts *opts,
 			ops = &signalfd_dump_ops;
 		else if (is_timerfd_link(link))
 			ops = &timerfd_dump_ops;
+        else if (is_anon_link_type(link, "[nvidiaevent]")) {
+            e->type = FD_TYPES__NVIDIA;
+            pr_debug("found nvidia fd. skipping...\n");
+            return 0;
+        }
 		else
 			return dump_unsupp_fd(&p, lfd, "anon", link, e);
 
@@ -835,12 +852,17 @@ int collect_fd(int pid, FdinfoEntry *e, struct rst_info *rst_info, bool fake)
 
 	fdesc = find_file_desc(e);
 	if (fdesc == NULL) {
+        /* pretend collection was successfull... */
+        if (e->type == FD_TYPES__NVIDIA) return 0;
 		pr_err("No file for fd %d id %#x\n", e->fd, e->id);
 		return -1;
 	}
 
-	if (!collect_fd_to(pid, e, rst_info, fdesc, fake, false))
+	if (!collect_fd_to(pid, e, rst_info, fdesc, fake, false)) {
+        /* pretend collection was successfull... */
+        if (e->type == FD_TYPES__NVIDIA) return 0;
 		return -1;
+    }
 
 	return 0;
 }
diff --git a/criu/include/image.h b/criu/include/image.h
index 1b2cdadf..b387087c 100644
--- a/criu/include/image.h
+++ b/criu/include/image.h
@@ -84,6 +84,7 @@
 #define VMA_AREA_VVAR		(1 <<  12)
 #define VMA_AREA_AIORING	(1 <<  13)
 
+#define VMA_NVIDIA          (1 <<  27)
 #define VMA_CLOSE		(1 <<  28)
 #define VMA_NO_PROT_WRITE	(1 <<  29)
 #define VMA_PREMMAPED		(1 <<  30)
diff --git a/criu/include/util.h b/criu/include/util.h
index 1e2fec81..e92f1c4b 100644
--- a/criu/include/util.h
+++ b/criu/include/util.h
@@ -134,6 +134,7 @@ extern int do_open_proc(pid_t pid, int flags, const char *fmt, ...)
 		__f;							\
 	 })
 
+#define DEVNVIDIA   (makedev(195,0))
 #define DEVZERO		(makedev(1, 5))
 
 #define KDEV_MINORBITS	20
diff --git a/criu/pie/restorer.c b/criu/pie/restorer.c
index d3b459c6..a8036f4c 100644
--- a/criu/pie/restorer.c
+++ b/criu/pie/restorer.c
@@ -653,6 +653,11 @@ static unsigned long restore_mapping(VmaEntry *vma_entry)
 	if (vma_entry_is(vma_entry, VMA_ANON_SHARED) && (vma_entry->fd != -1UL))
 		flags &= ~MAP_ANONYMOUS;
 
+    if (vma_entry_is(vma_entry, VMA_NVIDIA)) {
+        pr_debug("\tskipping nvidia vma\n");
+        flags |= MAP_ANONYMOUS;
+    }
+
 	/* See comment in premap_private_vma() for this flag change */
 	if (vma_entry_is(vma_entry, VMA_AREA_AIORING))
 		flags |= MAP_ANONYMOUS;
@@ -1357,12 +1362,18 @@ long __export_restore_task(struct task_restore_args *args)
 		sys_close(args->uffd);
 	}
 
+    printf("#################### I'm here *wave*\n");
+
 	/*
 	 * OK, lets try to map new one.
 	 */
 	for (i = 0; i < args->vmas_n; i++) {
 		vma_entry = args->vmas + i;
 
+        /* skip nvidia vma */
+        if (vma_entry_is(vma_entry, VMA_NVIDIA))
+            continue;
+
 		if (!vma_entry_is(vma_entry, VMA_AREA_REGULAR) &&
 				!vma_entry_is(vma_entry, VMA_AREA_AIORING))
 			continue;
@@ -1450,6 +1461,9 @@ long __export_restore_task(struct task_restore_args *args)
 		if (!(vma_entry_is(vma_entry, VMA_AREA_REGULAR)))
 			continue;
 
+        if (vma_entry_is(vma_entry, VMA_NVIDIA))
+            continue;
+
 		if ((vma_entry->prot & PROT_WRITE) ||
 				(vma_entry->status & VMA_NO_PROT_WRITE))
 			continue;
@@ -1478,6 +1492,9 @@ long __export_restore_task(struct task_restore_args *args)
 		if (!vma_entry->has_madv || !vma_entry->madv)
 			continue;
 
+        if (vma_entry_is(vma_entry, VMA_NVIDIA))
+            continue;
+
 		for (m = 0; m < sizeof(vma_entry->madv) * 8; m++) {
 			if (vma_entry->madv & (1ul << m)) {
 				ret = sys_madvise(vma_entry->start,
diff --git a/criu/proc_parse.c b/criu/proc_parse.c
index 1a5722ea..eaacb980 100644
--- a/criu/proc_parse.c
+++ b/criu/proc_parse.c
@@ -168,12 +168,16 @@ static void parse_vma_vmflags(char *buf, struct vma_area *vma_area)
 
 	__parse_vmflags(buf, &vma_area->e->flags, &vma_area->e->madv, &io_pf);
 
+    if (vma_area->vmst && S_ISCHR(vma_area->vmst->st_mode) && (vma_area->vmst->st_rdev == makedev(195, 0))) {
+        /* /dev/nvidia0 -- ignore! */
+        vma_area->e->status |= VMA_NVIDIA;
+    }
 	/*
 	 * vmsplice doesn't work for VM_IO and VM_PFNMAP mappings, the
 	 * only exception is VVAR area that mapped by the kernel as
 	 * VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP
 	 */
-	if (io_pf && !vma_area_is(vma_area, VMA_AREA_VVAR))
+    else if (io_pf && !vma_area_is(vma_area, VMA_AREA_VVAR))
 		vma_area->e->status |= VMA_UNSUPP;
 
 	if (vma_area->e->madv)
@@ -584,7 +588,9 @@ static int handle_vma(pid_t pid, struct vma_area *vma_area,
 			/* regular file mapping -- supported */;
 		else if (S_ISCHR(st_buf->st_mode) && (st_buf->st_rdev == DEVZERO))
 			/* devzero mapping -- also makes sense */;
-		else {
+        else if (S_ISCHR(st_buf->st_mode) && (st_buf->st_rdev == DEVNVIDIA)) {
+            vma_area->e->flags = VMA_NVIDIA;
+        } else {
 			pr_err("Can't handle non-regular mapping on %d's map %"PRIx64"\n", pid, vma_area->e->start);
 			goto err;
 		}
